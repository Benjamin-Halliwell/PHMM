---
title: "Multi-Response Phylogenetic Mixed Modelling: a tutorial"
author: "Ben Halliwell, Luke Yates & Barbara Holland"
header-includes:
  - \usepackage{mathtools}
date: "XX/XX/2022"
bibliography: bib_phmm.bib
link-citations: true
output: 
  html_document:
    number_sections: false
    toc: true 
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse); library(ggplot2); library(knitr); library(brms); library(MCMCglmm)
library(rstan); library(geiger);library(ape);library(ape);library(caper); library(parallel); library(coda)
knitr::opts_chunk$set(echo = TRUE, dev="png",
               dpi=96)
```


### Introduction

This tutorial is associated with the article "Multi-Response Phylogenetic Mixed Modelling: Theory, Implementation and Recommendations"

EcoEvoRxiv preprint DOI XXXXXXX

by

Ben Halliwell, Luke Yates & Barbara Holland   



<!-- PMM is motivated by the observation that closely related species tend to resemble each other phenotypically (a phenomenon known as phylogenetic signal), meaning species often do not represent independent data points with respect to evolutionary hypotheses. Instead, we must test for non-independence  and adjust our analyses accordingly. A central assumption of PMM therefore, is that we can combine a molecular phylogeny with a model of evolution (nominally, Brownian Motion (BM)) to generate a covariance matrix that defines the expected phenotypic similarity among taxa. The strength of this signal is optimised from the data during model fit, scaling the magnitude of effects to produce a phylogenetically informed regression. For univariate (UV) cases, this approach only estimates phylogenetic signal in the response variable, while any predictor variables in the model are assumed not to display phylogenetic signal. This assumption is commonly violated in analyses of real world data sets (where predictor variables often represent species traits that are themselves subject to phylogenetic effects), leading to identifiability issues. This problem is effectively addressed by moving offending predictor variables to the LHS of the model equation in multi-response (MR) implementations. This way, phylogenetic signal is simultaneously evaluated for all relevant traits, allowing (co)variances between response variables to be partitioned across multiple levels in the model hierarchy (e.g. phylogenetic and independent). This partitioning is important because phenotypic covariances (i.e., covariance on the level of traits measured), Cov(y1,y2), represent the sum of covariances on hierarchically lower levels, which need not align in magnitude or even direction. Thus, for comparative analyses of species traits with sufficient replication, MR-PMM should be preferred, as it offers more informative outputs with respect to evolutionary hypotheses. -->

In this tutorial we will cover how to implement multi-response (MR) phylogenetic mixed models (PMM) in two popular R packages, MCMCglmm and brms. While frequentist implementations of the PMM are available (e.g., pglmm() in the "phyr" package), we advocate for a Bayesian approach due to 1) greater flexibility in fitting non-Gaussian response traits 2) suitability for estimating variance components associated with structured random effects; 3) the ability to sample conditional multivariate distributions, avoiding intractable integration problems faced by frequentist techniques.

Throughout this tutorial, we explore a low dimensional example (tree with only 5 taxa) in order to show full workings of the matrix manipulations that underlie the models specified. This is for the sake of exposition only; analyses of the form presented will typically require much higher phylogenetic replication to produce reliable estimates of, for example, phylogenetic correlations (Housworth et al. 2004). Thus, while the mathematical workings presented follow a 5 taxa example, model outputs are based on analyses from simulations including 250 taxa.

\

### Model 1 - Univariate Gaussian

\

#### Model Explanation

For the case of a single Gaussian trait, our response variable, $y$, is modeled directly as a linear combination of the fixed effects $\mu$, a phylogenetic random effect, $b$, and residual variance, $e$.

\

\begin{eqnarray}
\mathbf{y} &=& \boldsymbol{\mu} + \mathbf{b} + \mathbf{e}\\[2mm]
\end{eqnarray}\

\

where $\mu$ represents,

\

\begin{eqnarray}
\boldsymbol{\mu}  = \beta_0 + \beta_1\boldsymbol{X_1} + \ldots + \beta_{k}\boldsymbol{X_{k}}
\end{eqnarray}

\

In order to capture the expected influence of co-ancestry on $y$, (similar values among closely related taxa), the distribution of our random effect, $b$, is multivariate normal, with mean 0 and (co)variance given by $\sigma_{b}C$, 

\

\begin{eqnarray}
b &\sim& \mbox{MVN}(0, \sigma^2_{b}C)\\
\end{eqnarray}\

<!-- The phylogenetic variance (e.g., Brownian rate), $\sigma_{b}$, is a scalar to be estimated by the model and $A$ is a fixed $n\times n$ -->
<!-- phylogenetic VCV matrix, where $n$ is the number of taxa in the tree. This model therefore takes as input a phylogenetic tree (topology and branch lengths), which is assumed to be known without error. The $A$ matrix itself is derived by taking the inverse of the distance matrix of the tree. It gives the expected (co)variance among taxa in the value of $y$ assuming some model of evolution (e.g. BM) along the branches of that tree. -->

Here, $C$ is a fixed $n\times n$ phylogenetic VCV matrix, where $n$ is the number of taxa in the tree, and $\sigma_{b}$, the phylogenetic variance, is a scalar to be estimated by the model. This model therefore takes as input a phylogeny (topology and branch lengths), which is assumed to be known without error. The $C$ matrix is derived from the similarity matrix of the phylogeny. This gives the expected (co)variance among taxa in $y$ assuming BM evolution.

\

\begin{eqnarray}
C &=& 
\begin{pmatrix}C_{11} & C_{12} & \ldots & C_{1n} \\ 
                C_{21} & C_{22} & \ldots & C_{2n} \\
                \vdots & \vdots & \ddots & \vdots \\ 
                C_{n1} & C_{n2} & \ldots & C_{nn} \\ 
\end{pmatrix}
\end{eqnarray}\


In contrast, the identity matrix $I$ (an $n\times n$ matrix with 1 in all diagonal elements and 0 in all off-diagonal elements) encodes independent residual error associated with each observation (taxon) in the distributional statement for the errors:

\

\begin{eqnarray}
\mathbf{e} &\sim& \mbox{MVN}(0, \sigma^2_{e}I)\\
\end{eqnarray}\

#### Example
Consider the following 5-taxon phylogeny with similarity between taxa shown on the x axis:

```{r, fig.width=5, fig.align='center'}
t.toy2 <- read.tree(text='((5:3, (4:2, 3:2):1):1, (2:1, 1:1):3);')
plot(t.toy2, label.offset=0.1, edge.width=1.5)
axis(1, at = seq(0,4,by=1), labels = seq(0,4,by=1), line = 0.5)
title(xlab="similarity")
```

For this phylogeny, the similarity matrix (elements expressing the sum of shared branch lengths between two taxa, $i$ and $j$), $C$, is:

\

\begin{eqnarray}
C &=& 
\begin{pmatrix}C_{11} & C_{12} & C_{13} & C_{14} & C_{15} \\ 
                C_{21} & C_{22} & C_{23} & C_{24} & C_{25} \\
                C_{31} & C_{32} & C_{33} & C_{34} & C_{35} \\
                C_{41} & C_{42} & C_{43} & C_{44} & C_{45} \\
                C_{51} & C_{52} & C_{53} & C_{54} & C_{55} \\
                \end{pmatrix}
&=&                
\begin{pmatrix} 4 & 3 & 0 & 0 & 0 \\ 
                3 & 4 & 0 & 0 & 0 \\
                0 & 0 & 4 & 1 & 1 \\
                0 & 0 & 1 & 4 & 2 \\
                0 & 0 & 1 & 2 & 4 \\
                \end{pmatrix}

                
\end{eqnarray}\


In order to facilitate comparison between phylogenetic and independent contributions when partitioning the variance, $C$ is often standardised to the unit diagonal (i.e., re-scaled to a correlation matrix) prior to analyses, such that,

\

\begin{eqnarray}
C_{cor} &=& 
\begin{pmatrix} 1 & 0.75 & 0 & 0 & 0 \\ 
                0.75 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0.25 & 0.25 \\
                0 & 0 & 0.25 & 1 & 0.5 \\
                0 & 0 & 0.25 & 0.5 & 1 \\
                \end{pmatrix}
\end{eqnarray}\



The identity matrix $I$ for this model is:

\begin{eqnarray}
I &=& 
\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\ 
                0 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                \end{pmatrix}
\end{eqnarray}\

\

#### Data Simulation and Model Specification

Implementing these models in R is fairly straight forward in both MCMCglmm and brms. But first, let's simulate some data.
To simulate data under this model, we simply construct our variable, $y$, from the linear combination of predictors specified by
the model, by supplying vectors of length $n$ for each of the quantities $\mu$, $b$, and $e$. For Gaussian variables
this can be done directly. For non-Gaussian variables simulation is a two-step process where $b$ and $e$ are simulated on the link scale to determine the mean and the response values themselves are subsequently drawn from the appropriate distribution (see section 3). In this example, we will simulate from an intercept only model ($\mu$ = $\beta_0$).

\

```{r eval=FALSE}

## SIMULATION

# simulate tree
n = 250 # number of species
phy <- geiger::sim.bdtree(b=1, d=0, stop="taxa", n=n, extinct=FALSE)

# create VCV matrix from tree, scale to correlation matrix with corr = T
C = ape::vcv.phylo(phy, corr = T)

# identity matrix
I = diag(n)

# fixed effects (intercept only)
u = 0

# phylogenetic variance
sigma_phy = 1

# residual variance
sigma_ind = 1

# simulate phylogenetic random effects as one draw from a MVN
b = MASS::mvrnorm(1,rep(0,n),sigma_phy*C)

# simulate residuals
e = MASS::mvrnorm(1,rep(0,n),sigma_ind*I)

# construct response from the linear predictor
y = u + b + e

# generate df
animal <- phy$tip.label # "animal" is a reserved term in MCMCglmm for taxon ID
d <- data.frame(animal,y)

## PLOT HEATMAP of traits against phy

```

\

With our tree and trait data simulated, we can now fit the model:

\

```{r eval=FALSE}

## MCMCglmm 
p.m.1 <- list(G = list(G1 = list(V = 1, nu = 0.002)), 
              R = list(V = 1, nu = 0.002))
m.1 <- MCMCglmm(y ~ 1,
                random = ~animal,
                pedigree = phy, 
                family = c("gaussian"), 
                data = d, 
                prior = p.m.1,
                nitt = 210000, burnin = 1000, thin = 20,
                pr = TRUE, verbose = F)


## BRMS
p.b.1 <- set_prior("student_t(3, 0, 2.5)", class = c("sd","sigma","Intercept"), lb = c(0,0,NA))
b.1 <- brm(y ~ 1 + (1|gr(animal, cov = C)), 
            data = d,
            prior = p.b.1,
            family = gaussian(), 
            data2 = list(C = C),
            cores = 1, chains = 2, iter = 50, thin = 3)

```

\

#### Model Syntax (MCMCglmm vs. brms) 

The code above fits the same model in MCMCglmm and brms. In MCMCglmm, `animal` is a reserved term used to identify individuals/taxa in a quantitative genetic/phylogenetic analysis. The random effect specification `~animal` instructs MCMCglmm to fit a random effect at the individual/taxon level with covariance structure supplied via the `pedigree` argument. For `pedigree`, MCMCglmm accepts a `phylo` object directly and performs the necessary steps to derive the matrix $C$ under the hood. The remaining arguments specify the data, the priors, and the sampler settings. The argument `pr` is used to retain  the posterior distribution of random effects.

In brms, the phylogenetic random effect can be encoded in the style of lme4 `(1|gr(animal, cov = C))`, where `(1|x)` specifies random intercepts and `gr(animal, cov = C)` encodes the phylogenetic group structure.

It is not necessary to specify a prior to fit this model in either MCMCglmm or brms because sensible defaults are used automatically. However, we choose to explicitly specify (current default) priors to ensure repeatability, should the defaults change in the future. A key difference between these packages is the implemented Monte Carlo sampling method and the subsequent choice of priors. MCMCglmm is based on Gibbs sampling, which requires conjugate prior distributions to reduce sampling time through analytic computations. brms uses Hamiltonian Monte Carlo sampling which is an efficient hybrid of optimisation and sampling approaches that places no restrictions on the choice of prior. 

\

#### Convergence Diagnostics

Basic convergence diagnostics are easily obtained for each package. As a first step, it is advisable to perform visual checks of the MCMC sample trace to confirm adequate mixing and stationary chains.

```{r, eval = F}

# visual check for convergence in MCMC chains
plot(m.1$VCV)
plot(b.1)


```


Another standard indicator of sampling adequacy is the effective sample size (ESS) of each parameter estimate. In the presence of auto-correlation between MCMC samples, the ESS will be reduced relative to the thinned sample number, with low ESS indicating poor sampling. ESS is reported in the model summary for both MCMCglmm and brms.

```{r, eval = F}

# model summaries
summary(m.1)
b.1

# calculate autocorrelation in MCMC draws (not an issue in brms)
autocorr(m.1$VCV)


```


brms also reports $\widehat{R}$ statistics, or potential scale reduction factors, by default for each parameter in the model summary. $\widehat{R}$ serves as a quantitative assessment of chain convergence, with values \verb|<| 1.05 indicating adequate convergence (Gelman XXX). For MCMCglmm, $\widehat{R}$ can be calculated from multiple MCMC chains of the same model using gelman.diag(). For more information on Bayesian model diagnostics, we direct the reader to (REF).


```{r, eval = F}

# calculate potential scale reduction factors for each variance component
# over multipl MCMC chains
m.1.2 <- mclapply(1:2, function(i) {
  MCMCglmm(y ~ 1,
                random = ~animal,
                pedigree = phy, 
                family = c("gaussian"), 
                data = d, 
                prior = p.m.1,
                nitt = 2100, burnin = 100, thin = 20,
                pr = TRUE, verbose = FALSE)
}, mc.cores=1)

m.1.2 <- lapply(m.1.2, function(m) m$VCV)
m.1.2 <- do.call(mcmc.list, m.1.2)
m.1.2 %>% as.matrix %>% Rhat


```

\

#### Model Validation

With a fitted model passing convergence diagnostics, the next step is to evaluate model performance through model validation procedures such as posterior predictive checks. Posterior predictive checks simulate data under the fitted model, then compare these replicated data sets or appropriate summary statistics to the observed data to identify any systematic discrepancies (\citealt{gelman2006data}, p. 158). It is very straightforward to run posterior predictive checks in brms

```{r, eval = F}
# posterior predictive checks
b.1 %>% pp_check(nsamples = 100)

```


However, a more rigorous and sophisticated approach to model validation of MR-PMM is leave-one-out (LOO) cross-validation (CV) (Roberts 2017; also see section 5 on Prediction in manuscript). LOO-CV .....


\

#### Inference

Having fit and validated our model, the next step is to make inferences on the parameters estimated. In the Bayesian paradigm, inference is based upon summary statistics of the posterior distributions of the model parameters. For example, hypothesis tests can be performed by evaluating whether a CI (e.g. 95\%) of the posterior of a parameter crosses zero. We can compare model outputs to confirm that we are indeed fitting the same model. 

```{r, eval = F}

summary(m.1) # MCMCglmm
summary(b.1) # brms

```


Intercept estimates are directly comparable between MCMCglmm and brms. However, MCMCglmm reports variance components where-as brms reports these quantities as standard deviations. As our simulations also specify standard deviations, we will re-scale estimates from MCMCglmm by calculating posterior means from the `sqrt()` of MCMC samples.


```{r, eval = F}

## PARAMETER ESTIMATES ##

# intercept
summary(m.1)$solutions
summary(b.1)[["fixed"]]

# phylogenetic variance (sigma_phy)
m.1$VCV[,1] %>% sqrt %>% quantile(probs = c(0.025,0.5,0.975))
sqrt(m.1$VCV[,"animal"])
summary(b.1)[["random"]]

# residual variance (sigma_ind)
sqrt(summary(m.1)$Rcovariances)
summary(b.1)[["spec_pars"]]

```

\

#### Phylogenetic Signal

An estimate of phylogenetic signal, the amount of variation in a trait explained by shared ancestry between species, in $y$ can be calculated as

\begin{eqnarray} \label{eq_h2}
h^2 = \sigma^2_{b}/(\sigma^2_{b}+\sigma^2_{e})
\end{eqnarray}\

```{r, eval = F}

# MCMCglmm
mean(m.1$VCV[,"animal"]/(m.1$VCV[,"animal"]+m.1$VCV[,"units"]))

# brms (clean this up)
mean(b.1$fit@sim$samples[[1]]$sd_animal__g1_Intercept/(b.1$fit@sim$samples[[1]]$sd_animal__g1_Intercept+b.1$fit@sim$samples[[1]]$sigma_g1))

```

We can also confirm that $h^2$ from our PMM is estimating the same quantity as the MLE of lambda from an equivalent pgls model.

```{r, eval = F}

## compare to MLE of lambda from PGLS fit
comp_dat <- comparative.data(t.toy, d.toy, animal, vcv=TRUE)
mod <- pgls(y ~ 1, data = comp_dat, lambda = "ML")
summary(mod)$param["lambda"]

```

\

### Model 2 - Multivariate Gaussian

\

#### Model Explanation

In a multivariate (MV) implementation, our response variables are modelled jointly, allowing both phylogenetic and independent (co)variances to be estimated. With this design, the phylogenetic random effects must also be realised jointly as a multivariate normal, with variance given by $\Sigma^{\mathrm{phy}} \otimes C$, the Kronecker product of a trait-level correlation matrix $\Sigma^{\mathrm{phy}}$ and the phylogenetic VCV matrix, $C$. With $m$ traits (response variables) and $n$ taxa in the phylogeny, $\Sigma^{\mathrm{phy}} \otimes C$ is an $mn\times mn$ VCV matrix containing phylogenetic (co)variances for all traits as well as between all traits. Notice that the two taxon-level variance structures we encountered in the univariate case above ($C$ and $I$) remain, but we must now also consider trait-level covariance operating at both the phylogenetic and independent level. This is achieved via the Kronecker operation. A MV-PMM with two Gaussian response variables takes the form,


\


\begin{eqnarray}
\begin{pmatrix}\mathbf{y}_1 \\
\mathbf{y}_2 \end{pmatrix} &=& 
\begin{pmatrix}\boldsymbol{\mu}_1 + \mathbf{b}_1 + \mathbf{e}_1 \\
               \boldsymbol{\mu}_2 + \mathbf{b}_2 + \mathbf{e}_2
\end{pmatrix}\\
\end{eqnarray}

\

where fixed effects are expressed as a linear combination of predictors,

\

\begin{eqnarray}
\begin{pmatrix}\boldsymbol{\mu}_1 \\ \boldsymbol{\mu}_2 \end{pmatrix} &=& 
\begin{pmatrix}\beta_{0,1}\mathbf{1} + \beta_{1,1}\boldsymbol{X_{1,1}} + \ldots + \beta_{k,1}\boldsymbol{X_{k,1}} \\
               \beta_{0,2}\mathbf{1} + \beta_{1,2}\boldsymbol{X_{1,2}} + \ldots + \beta_{k,2}\boldsymbol{X_{k,2}}
\end{pmatrix}\\
\end{eqnarray}

\

and the phylogenetic random effects and independent residuals are drawn from multivariate normal distributions,

\

\begin{eqnarray}
\begin{pmatrix}\mathbf{b}_1 \\
\mathbf{b}_2 \end{pmatrix} &\sim& \mbox{MVN}(0, \Sigma^{\mathrm{phy}} \otimes C)\\
\begin{pmatrix}\mathbf{e}_1 \\
\mathbf{e}_2 \end{pmatrix} &\sim& \mbox{MVN}(0, \Sigma^{\mathrm{ind}} \otimes I)\\[2mm]

\Sigma &=& \Sigma^{\mathrm{phy}} \otimes C + \Sigma^{\mathrm{ind}} \otimes I
\end{eqnarray}\


Here, $\Sigma^{\mathrm{phy}}$ is an $m\times m$ phylogenetic trait-level VCV matrix and $m$ is the number of response traits in the model,

\

\begin{eqnarray}
\Sigma^{\mathrm{phy}}
= 
\begin{pmatrix}\Sigma^{\mathrm{phy}}_{11} & \Sigma^{\mathrm{phy}}_{12} & \ldots & \Sigma^{\mathrm{phy}}_{1m} \\ 
                \Sigma^{\mathrm{phy}}_{21} & \Sigma^{\mathrm{phy}}_{22} & \ldots & \Sigma^{\mathrm{phy}}_{2m} \\
                \vdots & \vdots & \ddots & \vdots \\ 
                \Sigma^{\mathrm{phy}}_{m1} & \Sigma^{\mathrm{phy}}_{m2} & \ldots & \Sigma^{\mathrm{phy}}_{mm} \\ \end{pmatrix}
&=& 
\begin{pmatrix}(\Sigma^{\mathrm{phy}}_1)^2 & \rho^{\mathrm{phy}}_{12}\Sigma^{\mathrm{phy}}_1 \Sigma^{\mathrm{phy}}_2 & 
                \ldots & \rho^{\mathrm{phy}}_{1m}\Sigma^{\mathrm{phy}}_1 \Sigma^{\mathrm{phy}}_m \\ 
                \rho^{\mathrm{phy}}_{21}\Sigma^{\mathrm{phy}}_2 \Sigma^{\mathrm{phy}}_1 & (\Sigma^{\mathrm{phy}}_2)^2 & 
                \ldots & \rho^{\mathrm{phy}}_{2m}\Sigma^{\mathrm{phy}}_2 \Sigma^{\mathrm{phy}}_m \\
                \vdots & \vdots & \ddots & \vdots \\ 
                \rho^{\mathrm{phy}}_{m1}\Sigma^{\mathrm{phy}}_m \Sigma^{\mathrm{phy}}_1 & 
                \rho^{\mathrm{phy}}_{m2}\Sigma^{\mathrm{phy}}_m\Sigma^{\mathrm{phy}}_2 &
                \ldots & 
                (\Sigma^{\mathrm{phy}}_m)^2 \\ \end{pmatrix}\\[2mm]

\end{eqnarray}
\

such that elements of $\Sigma^{\mathrm{phy}}$ have the general form,

\

\begin{eqnarray}
\Sigma^{\mathrm{\tiny {phy}}}_{ij} = \sigma^{\mathrm{\tiny {phy}}}_i\sigma^{\mathrm{\tiny {phy}}}_j\rho^{\mathrm{\tiny {phy}}}_{ij} \\
\end{eqnarray}

\

where $\rho_{ij}$ is the correlation between traits $i$ and $j$  and $\sigma_i$ is the standard deviation of trait $i$. Thus, returning to our 5-taxon example, a MV model with two Gaussian response traits (i.e., $m = 2$) will have VCV matrix for the phylogenetic random effects, $\Sigma^{\mathrm{phy}} \otimes C$, of the form:

\

<!-- Can't get parenthesis  around smallmatrix. Need \mathtools but how to load?  -->

\begin{eqnarray}

\Sigma^{\mathrm{phy}} \otimes C
&=& 
\begin{pmatrix} \Sigma^{\mathrm{phy}}_{11}C & \Sigma^{\mathrm{phy}}_{12}C  \\ 
                \Sigma^{\mathrm{phy}}_{21}C & \Sigma^{\mathrm{phy}}_{22}C  \\
\end{pmatrix}
&=&
\begin{pmatrix} \Sigma^{\mathrm{phy}}_{11}
                \left(\begin{smallmatrix} 
                4 & 3 & 0 & 0 & 0 \\ 
                3 & 4 & 0 & 0 & 0 \\
                0 & 0 & 4 & 1 & 1 \\
                0 & 0 & 1 & 4 & 2 \\
                0 & 0 & 1 & 2 & 4 \\
                \end{smallmatrix}\right) &
                \Sigma^{\mathrm{phy}}_{12}
                \left(\begin{smallmatrix} 
                4 & 3 & 0 & 0 & 0 \\ 
                3 & 4 & 0 & 0 & 0 \\
                0 & 0 & 4 & 1 & 1 \\
                0 & 0 & 1 & 4 & 2 \\
                0 & 0 & 1 & 2 & 4 \\
                \end{smallmatrix}\right) \\
                \Sigma^{\mathrm{phy}}_{21}
                \left(\begin{smallmatrix} 
                4 & 3 & 0 & 0 & 0 \\ 
                3 & 4 & 0 & 0 & 0 \\
                0 & 0 & 4 & 1 & 1 \\
                0 & 0 & 1 & 4 & 2 \\
                0 & 0 & 1 & 2 & 4 \\
                \end{smallmatrix}\right) &
                \Sigma^{\mathrm{phy}}_{22}
                \left(\begin{smallmatrix} 
                4 & 3 & 0 & 0 & 0 \\ 
                3 & 4 & 0 & 0 & 0 \\
                0 & 0 & 4 & 1 & 1 \\
                0 & 0 & 1 & 4 & 2 \\
                0 & 0 & 1 & 2 & 4 \\
                \end{smallmatrix}\right)\\
\end{pmatrix}

\end{eqnarray}\

\

Similarly, the VCV matrix for the independent residual errors, $\Sigma^{\mathrm{ind}} \otimes I$, is:

\


<!-- Can't get parenthesis  around smallmatrix. Need \mathtools but how to load?  -->

\begin{eqnarray}

\Sigma^{\mathrm{ind}} \otimes I
&=& 
\begin{pmatrix} \Sigma^{\mathrm{ind}}_{11}I & \Sigma^{\mathrm{ind}}_{12}I  \\ 
                \Sigma^{\mathrm{ind}}_{21}I & \Sigma^{\mathrm{ind}}_{22}I  \\
\end{pmatrix}
&=&
\begin{pmatrix} \Sigma^{\mathrm{ind}}_{11}
                \left(\begin{smallmatrix} 
                1 & 0 & 0 & 0 & 0 \\ 
                0 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                \end{smallmatrix}\right) &
                \Sigma^{\mathrm{ind}}_{12}
                \left(\begin{smallmatrix} 
                1 & 0 & 0 & 0 & 0 \\ 
                0 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                \end{smallmatrix}\right)\\
                \Sigma^{\mathrm{ind}}_{21}
                \left(\begin{smallmatrix} 
                1 & 0 & 0 & 0 & 0 \\ 
                0 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                \end{smallmatrix}\right)&
                \Sigma^{\mathrm{ind}}_{22}
                \left(\begin{smallmatrix} 
                1 & 0 & 0 & 0 & 0 \\ 
                0 & 1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 0 & 1 \\
                \end{smallmatrix}\right)\\
\end{pmatrix}

\end{eqnarray}\


__N.B. This example is purely for illustrative purposes. The parameters of this model are not estimable with such low phylogenetic replication (n = 5 taxa). However, the low dimension of $A$ and $I$ allow us to explicitly show the working of matrix manipulations.__

\

#### Data Simulation and Model Specification

With multiple response variables, we must now consider covariance between responses at both the phylogenetic and independent level. To incorporate this into our data simulations, we can specify correlation matrices which define the (co)variance structure of our random effects and independent residual errors.

```{r eval=FALSE}

## SIMULATE DATA

# number of traits
k = 2

# fixed effects (intercepts for each trait)
u = c(1,2)

## B is the phylogenetic trait-level VCV matrix (\Sigma^{\mathrm{phy}}). B specifies the phylogenetic variance in each trait (diagonals) as well as the phylogenetic covariance between traits (off-diagonals). Each unique element in B is to be estimated by the model. To construct B, we must first define its (co)variance components.
sig.B <- c(b11 = 0.4, b22 = 0.6) # sqrt of the phylogenetic variance for each trait
b12_rho = 0.5 # phylogenetic correlation coefficient
Bcor <- matrix(c(c(1,b12_rho), # phylogenetic correlation matrix
                 c(b12_rho,1)),k,k, byrow = T) 

# Construct B as point-wise product
# N.B. Kronecker used here just for ease of matrix formatting. Do not confuse with Kronecker operation described in the text for specifying the covariance of random effects a and residuals e (below)
B <- matrix(kronecker(sig.B, sig.B),k,k)*Bcor 

## E is the residual trait-level VCV matrix (\Sigma^{\mathrm{ind}}).
sig.E <- c(e11 = 0.1, e22 = 0.1) # sqrt of the residual variance for each trait
e12_rho = 0 # residual correlation coefficient
Ecor <- matrix(c(c(1,e12_rho), # residual correlation matrix
                 c(e12_rho,1)),k,k, byrow = T) 
E <- matrix(kronecker(sig.E, sig.E),k,k)*Ecor

# simulate phylogenetic random effects
b = mvrnorm(1,rep(0,n*k),kronecker(B,C)) # In the Kronecker, trait-level covariance captured by B, taxon-level covariance captured by C. 

# extract random effects for each trait from the vector, b.
b1 <- b[1:n]
b2 <- b[1:n + n]

# simulate residuals (on the link scale) and extract
e = mvrnorm(1,rep(0,n*k),kronecker(E,I))
e1 <- e[1:n]
e2 <- e[1:n + n]

# construct response traits from each linear predictor
y1 = u[1] + b1 + e1
y2 = u[2] + b2 + e2

# generate df
species <- phy$tip.label
d2 <- data.frame(species,y1,y2)
d2$animal <- d2$species
d2$obs <- 1:nrow(d2)

```

\

A MV model with two Gaussian response traits, such as the example provided above, can be specified in MCMCglmm and brms as follows:

```{r eval=FALSE}

## MCMCglmm 
p.m.2 <- list(G = list(G1 = list(V = diag(2), nu = 1.002)), 
              R = list(V = diag(2), nu = 1.002))
m.2 <- MCMCglmm(cbind(y1, y2) ~ trait-1,
                random = ~us(trait):animal,
                rcov = ~us(trait):units,
                pedigree = phy,
                family = c("gaussian","gaussian"), 
                data = d2, prior=p.m.2, 
                nitt=210000, burnin=10000, thin=200,
                pr = TRUE, verbose = FALSE)

## BRMS
p.b.2 <- ()
b.2 <- brm(mvbind(y1, y2) ~ (1|a|gr(animal, cov = A)),
            data = d2,
            prior = p.b.2,
            family = gaussian(), 
            data2 = list(A = C),
            cores = 4, chains = 4, iter = 6000, thin = 3)

```


\

#### Model Syntax

In MCMCglmm, we use `cbind()` to specify multiple response variables. The reserved term `trait` is used to specify fixed effects for all responses onm the LHS. In our example, `trait-1` suppresses the global intercept, instead fitting separate intercepts for each trait $y1$ and $y2$. With multiple response variables, it is now possible to consider covariance between responses at different levels of the model hierarchy. MCMCglmm offers several options for defining the structure of covariance matrices to be estimated (see Hadfield XXX). The argument `~us(trait)` specifies an unstructured (all elements estimated) covariance matrix with dimension equal to the number of response traits considered (here 2 x 2). The suffix `:animal` specifies this covariance matrix is on the level of the grouping factor `animal`, where-as `:units` encodes a residual covariance matrix.

In brms, we use `mvbind()` to specify multiple response variables. An index (here `|a|`, but any unique identifier is accepted) is used within the random effect specification to instruct brms to estimate the correlation between $y1$ and $y2$ at the animal group level. If omitted, only the correlation between $y1$ and $y2$ on the independent level will be estimated.

\

#### Inference

For MR cases, the parameters of greatest interest are the phylogenetic and residual (co)variance components. Using the notation presented above, phylogenetic signal is calculated for each trait by substituting elements of the parameterized (co)variance matrices $\Sigma^{\mathrm{\tiny phy}}$ and $\Sigma^{\mathrm{\tiny ind}}$ into the calculation of $h^2$. Similarly, phylogenetic and residual correlations are derived by substituting relevant elements into,

\begin{eqnarray} \label{eq_cor_PMM}
\rho^{\cdots}_{12} = \frac{\Sigma^{\cdots}_{12}}{\sqrt{(\Sigma^{\cdots}_{11} \times \Sigma^{\cdots}_{22})}}
\end{eqnarray}\

Posterior distributions of each pairwise correlation estimate are obtained by supplying vectors of posterior samples for each (co)variance parameter. These calculations are performed and reported by default in the brms model summary. For MCMCglmm, correlations can be calculated from (co)variance estimated with some basic manipulations

```{r eval=FALSE}

## MCMCglmm
# phylogenetic correlation between y1 and y2
mean(m.2$VCV[,"traity1:traity2.animal"]/sqrt(m.2$VCV[,"traity1:traity1.animal"]*m.2$VCV[,"traity2:traity2.animal"]))
# independent correlation between y1 and y2
mean(m.2$VCV[,"traity1:traity2.units"]/sqrt(m.2$VCV[,"traity1:traity1.units"]*m.2$VCV[,"traity2:traity2.units"]))

## brms
# phylogenetic correlation = cor(y1_Intercept,y2_Intercept)
# independent correlation = rescor(y1,y2)
summary(b.2)

```


We can see close agreement between the estimates from MCMCglmm and brms (i.e., within Monte Carlo error), with both packages able to recover the generating simulation parameters.


\

### Model 3 - Multivariate Non-Gaussian (Gaussian, Bernoulli)

\

#### Model Explanation

In previous simulations, we saw that Gaussian responses can be drawn directly from the MV structure, i.e., modeled via the identity link function. For non-Gaussian variables, (co)variances must be modeled on the link scale, e.g., for Poisson regression the mean is modeled with the log link while for binomial data, the probability of success is modeled with the logit link. To demonstrate this, we will again simulate and fit data under a bivariate model, this time taking a binomial response for $y2$.

\

\begin{eqnarray}
\begin{pmatrix}\mathbf{y_1} \\ \mathrm{logit}(\mathbf{p_2}) \end{pmatrix} &=& 
\begin{pmatrix}\boldsymbol{\mu}_1 + \mathbf{b}_1 + \mathbf{e}_1 \\
               \boldsymbol{\mu}_2 + \mathbf{b}_2 + \mathbf{e}_2 \\
\end{pmatrix}\\[2mm]
\\

\mathbf{y_2} &\sim& \mathrm{binomial}(\mathbf{p_2})

\end{eqnarray}

\

#### Data Simulation and Model Specification

Using our vectors of random effects and residuals simulated previously (on the link scale), we can now simply use the inverse link function to realise y2 as a binomial variable.

```{r eval=FALSE}

## SIMULATE DATA

# construct response traits from each linear predictor
y1 = u[1] + b1 + e1 # gaussian
y2 = rbinom(n,1,plogis(u[2] + b2 + e2)) # binomial

# generate df
species <- phy$tip.label
d3 <- data.frame(species,y1,y2)
d3$animal <- d3$species
d3$obs <- 1:nrow(d3)

```


\

Specification of this model changes very little for MCMCglmm; the second argument to `family` is simply specified as "categorical". Prior specification requires more careful attention. For binomial variables, the residual variance is not identifiable (REF). This is handled in MCMCglmm by fixing the residual variance of the binomial response to a nominal value (e.g., V = 1) in the prior specification. Fixing at higher values of V can improve mixing of the chain, but may also lead to numerical problems (see Hadfeild XXX). While it is theoretically possible to estimate residual correlations with a fixed residual variance (i.e., fixing the width of the error variance for one trait does not prevent correlation between joint multivariate draws), we point the user toward some practical concerns identified in the literature (REF).

For brms, it is useful to specify separate formulae for each response variable when considering different error families. Unlike MCMCglmm, brms does not model additive overdispersion by default for non-gaussian traits. Thus, in order to model residual (co)variances, it is necessary to specify an additive overdispersion term in the form an observation level random effect, ` (1|q|obs)`. However, this introduces a non-identifiability issue for the Gaussian error term, which cannot be silenced with default brms coding. Here, for simplicity, we have just constrained the Gaussian error term to be small (`sigma = 0.1`). A more appropriate (albeit technically demanding) solution is to edit the underlying stan code to prevent estimation of the redundant Gaussian error term (shown here - link).


```{r eval=FALSE}
# MCMCglmm

# NOTE - NEED TO USE DIFFERENT PRIORS FOR NON-GAUSSIAN RESPONSES
p3 <- list(G = list(G1 = list(V = diag(4), nu = 3.002)),
           R = list(V = diag(4), nu = 3.002))

m.3 <- MCMCglmm(cbind(y1, y2) ~ trait-1,
                random = ~us(trait):animal,
                rcov = ~us(trait):units,
                pedigree = phy,
                family = c("gaussian", "categorical"), 
                data = d3, prior=p3, 
                nitt=210000, burnin=10000, thin=200,
                pr=TRUE,verbose = FALSE)

# BRMS
bf_y1 <- bf(y1 ~ 1 + (1|p|gr(animal, cov = A)) + (1|q|obs), sigma = 0.1) + gaussian()
bf_y2 <- bf(y2 ~ 1 + (1|p|gr(animal, cov = A)) + (1|q|obs)) + bernoulli()

b.3 <- brm(bf_y1 + bf_y2 + set_rescor(FALSE),
          data = d3, 
          family = gaussian(), 
          data2 = list(A = C),
          cores=4,
          chains=4, iter = 2000, thin = 1
)

```

\

#### Inference

Because the residual variance for binomial traits is fixed in MCMCglmm, it may be desirable to re-scale the phylogenetic correlations relative to the magnitude of this fixed residual variance (see Hadfield XXXX).


Another consequence of fixing the residual variance is that $h^2$ is no longer an appropriate estimate of phylogenetic signal. For our example, the amount of variation in our binomial trait $y2$ explained by shared ancestry may instead be estimated as the intraclass correlation coefficient

\begin{eqnarray}
ICC = \Sigma^{\mathrm{phy}}_{11}/(\Sigma^{\mathrm{phy}}_{11}+V+\pi^{2/3})
\end{eqnarray}

where $V$ is the level of residual variance (additive over-dispersion) fixed in the prior specification (here, V = 1) and $\pi^{2/3}$ is the distribution specific variance term for the binomial (see Hadfield XXX; Nakagawa and Schielzeth XXX)

\


### Leaf Traits in Eucalyptus


#### Model Validation

Insert example from Eucalyptus model


\
\

#### NOTES


For a reference use at symbol @Royle2004 , see the bib_phmm.bib file for standard bibtex. 

\

# References

